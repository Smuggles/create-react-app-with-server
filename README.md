# `create-react-app` with a server example

 [![Dolpins](https://cdn.rawgit.com/fullstackio/cq/master/doc/readme/dolphins-badge-ff00ff.svg)](https://www.fullstackreact.com)

This project demonstrates using the setup generated by `create-react-app` alongside a Node Express API server. You can use it as a starting point for your own projects.

## Running

```
git clone git@github.com:fullstackreact/create-react-app-with-server.git
cd create-react-app-with-server
npm i
npm start
```

## Overview

`create-react-app` configures a Webpack development server to run on `localhost:3000`. This development server will bundle all static assets located under `src/`. All requests to `localhost:3000` will serve `index.html` which will include Webpack's `bundle.js`.

In this example, the React component `App` makes a request to an API server (`server.js`). The user interacts exclusively with the Webpack dev server at `localhost:3000`. The Webpack dev server communicates with the API server when needed at `localhost:3001`:

![Flow diagram](./flow-diagram.png)

This setup uses [node-foreman](https://github.com/strongloop/node-foreman) for process management. Executing `npm start` instructs Foreman to boot both the Webpack dev server and the API server.

## DIY

You can get here yourself using `create-react-app` as a starting point.

The additions to the `create-react-app` boilerplate are listed below.

### `package.json`

Includes extra dependencies for our API server.

`npm start` executes `nf start` (Foreman's start command).

### `Procfile`

Foreman commands for booting the Webpack dev server (`web`) and the API server (`api`):

```
web: ./node_modules/.bin/react-scripts start
api: PORT=3001 ./node_modules/.bin/babel-node server.js
```

(More info on `node-foreman` and Procfiles [here](https://github.com/strongloop/node-foreman)).

### `App.js`

Inside of the `App` component, we make a sample request to the API server using Fetch:

```javascript
    fetch('http://localhost:3001/api/forecast', {
      accept: 'application/json',
    }).then(parseJSON)
```

### `server.js`

The API server. The important bit of configuration is **white-listing an origin domain**.

The user is communicating with `localhost:3000`. Yet, as demonstrated above, Fetch makes a request to `localhost:3001` â€” a different domain. Browsers restrict HTTP requests within scripts to the same domain.

In our API server, we let the browser know it's OK if a request is originating from `localhost:3000`:

```javascript
const allowCrossDomain = function (req, res, next) {
  res.header('Access-Control-Allow-Origin', 'http://localhost:3000');
  res.header('Access-Control-Allow-Methods', 'GET,PUT,POST,DELETE');
  res.header('Access-Control-Allow-Headers', 'Content-Type');

  next();
};
app.use(allowCrossDomain);
```

## TODO

* Add logic to make this work in a production environment
